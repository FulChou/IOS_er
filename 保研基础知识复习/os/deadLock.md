## 死锁：[参考资料](https://blog.csdn.net/rabbit_in_android/article/details/50530960)

是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相**等待的现象**，若无外力作用，它们都将无法推进下去。

死锁原因（AB互相索取资源）：
1. 系统资源不足。
2. 进程运行推进的顺序不合适。
3. 资源分配不当等。

死锁条件（四项）
产生死锁的四个必要条件：
1. 互斥条件：一个资源每次只能被一个进程使用。
2. 占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不可强行占有:进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁

- 死锁的解除与预防：

理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和
解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态
的情况下占用资源。因此，对资源的分配要给予合理的规划

- 处理死锁的基本方法：

**死锁预防**：通过设置某些限制条件，去破坏死锁的四个条件中的一个或几个条件，来预防发生死锁。但由于所施加的限制条件往往太严格，因而导致系统资源利用率和系统吞吐量降低。

**死锁避免** ：允许前三个必要条件，但通过明智的选择，确保永远不会到达死锁点，因此死锁避免比死锁预防允许更多的并发。

**死锁检测** ：不须实现采取任何限制性措施，而是允许系统在运行过程发生死锁，但可通过系统设置的检测机制及时检测出死锁的发生，并精确地确定于死锁相关的进程和资源，然后采取适当的措施，从系统中将已发生的死锁清除掉。

**死锁解除** ：与死锁检测相配套的一种措施。当检测到系统中已发生死锁，需将进程从死锁状态中解脱出来。常用方法：撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程。死锁检测盒解除有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。

- 死锁预防具体做法：

死锁预防：破坏死锁的四个条件中的一个或几个。

(1)互斥：它是设备的固有属性所决定的，不仅不能改变，还应该加以保证。

(2)占有且等待：

为预防占有且等待条件，可以要求进程一次性的请求所有需要的资源，并且阻塞这个进程直到所有请求都同时满足。这个方法比较低效。

(3)不可抢占：

预防这个条件的方法：

如果占有某些资源的一个进程进行 进一步资源请求时被拒绝，则该进程必须释放它最初占有的资源。

如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另外一个进程，要求它释放资源。

(4)循环等待：通过定义资源类型的线性顺序来预防。

如果一个进程已经分配了R类资源，那么接下来请求的资源只能是那些排在R类型之后的资源类型。该方法比较低效

三 死锁避免：

(1)两种死锁避免算法：

**进程启动拒绝** ：如果一个进程的请求会导致死锁，则不启动该进程。

**资源分配拒绝** ：如果一个进程增加的资源请求会导致死锁，则不允许此分配(银行家算法)。

**(2)银行家算法：**
先找出need matrix(还需要多少资源) ： need = MAX-Allocation;

接下來找出need比available小的

1.如果request<=need，转向步骤2；否则认为出错，因为请求资源大于需要资源。

2.如果request<=available，转向步骤3,；否则尚无足够资源，进程p阻塞；

3.系统尝试为把资源分配给进程P，并修改available、allocation和need的数值。

4.系统执行安全性算法，检查此次分配后系统是否处于安全状态，若安全，才正式将资源分配给进程P，否则将本次试探性分配作废，让进程P等待。



**安全状态**：系统能按照某种进程顺序，为每个进程分配资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利完成。

给了之后，能不能安全：能不能找到一个安全的顺序来进行资源的分配。



(3)安全性算法：判断安全状态：

1.设置两个向量：

*工作向量work：表示系统可提供给进程继续运行的所需的各类资源的数目，执行安全算法开始时，work=available。

*finish：表示系统是否有足够资源分配给进程，使之运行完成。开始时先做finish[i]=false；当有足够资源分配给进程时再令finish[i]=true。

2.从进程集合找到一个满足下列条件的进程：

*finish[i]=false；

*need<=work；（能够分配给它完全执行掉）

*若找到执行步骤3；否则执行步骤4；

3.当进程P获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：

*work=work+allocation(P)；

*finish[i]=true；

*循环执行步骤2；

4.如果所有进程的finish=true，则表示系统处于安全状态；否则，系统处于不安全状态。




四 死锁检测和解除

(1)死锁检测算法

(2)死锁的解除：

两种常用的死锁解除方法：**剥夺资源和撤销进程。**